## 6.437 : Deciphering with Metropolis Hastings
Decrypting a Substitution Cipher
Author: Sarah Hensley

A [simple substitution cipher](https://en.wikipedia.org/wiki/Substitution_cipher) is a way of encoding a message, in which each character of plaintext is replaced with some other character. This project decrypts the resulting ciphertext using the Metropolis-Hastings algorithm. To try it yourself, consider either using the example ciphertext included in this repository, or try encoding and then decoding your own text!

# Description of Metropolis-Hastings
Metropolis-Hastings is a Markov chain Monte Carlo (MCMC) method for sampling from a high-dimensional probability distribution. We assume that we know the unnormalized probability distribution that our data comes from, but because of the dimension, we cannot normalize it or sample from it directly. Instead, we construct a Markov chain whose stationary distribution is equal to our true distribution. Thus, after the appropriate mixing time, our Markov chain will produce samples drawn from the same distribution as the one we want to sample from. To do this, on each time step, we propose a new sample, according to some transition function. Then, with some probability, we accept this as our new state, or we reject it and retain our current state. Each state is a sample. The transition probabilities and acceptance probability depend on the particular problem at hand.

In this project, we have the unnormalized distribution of the probability of each of the characters 'abcdefghijklmnopqrstuvwxyz .' appearing, as well as the distribution for, given the n^{th} character in a string, what the next character will be. The goal is to determine the *cipher*, which is the mapping from the encrypted text to plaintext. We do this by sampling from the distribution of possible ciphers. We assume that, for long blocks of text, the true cipher is dramatically more likely than any other possible cipher. (For example, we have a much higher probability of seeing 'the' than 'zfw' in text.) Thus, once we reach the stationary distribution of our Markov chain, almost every sample will be the correct cipher. We can simply take one sample and accept this as the true cipher!

Note that, if you try encoding your own text, the algorithm has a higher likelihood of correctly cracking the code when you input a longer string of text. The probability of 'the' occurring may be (probability of 't') * (probability of 'h' following 't') * (probability of 'e' following 'h') = (0.05*0.1*0.1), compared to 'zfw' having probability (0.02*0.001*0.001). While these are an order of magnitude different, to have almost every sample be the correct cipher, the difference must be very dramatic, and so longer strings drive the probability of incorrect ciphers to zero much more quickly compared to the true cipher. As a result, having longer strings improves the chance of correctly breaking the cipher. 

# Description of the Implementation
My implementation included a number of clever ideas specific to this application.

First, we need to determine when we have reached the stationary distribution. In my implementation, every time a proposed new cipher is rejected, a counter increments. When this counter reaches some threshold, we decide that we have the true cipher, as this indicates that we have reached a local minimum. Because the problem is nonconvex, the local minimum is not guaranteed to be the global minimum (i.e. the correct cipher). For example, the cipher often swaps "qu" with ". ", as both of these frequently come in pairs. One way to combat this (and a to-do in this project!) is to do a check for common words, such as 'the', and accept the cipher as correct if that is also satisfied.

Next, all probabilities are calculated as log probabilities. This changes the calculation of the probability of a string occurring from a product to a sum; this is important, as the floating point precision does not allow for an accurate calculation when multiplying hundreds or thousands of values less than 0.01.

A significant problem with MCMC methods is that, if the initial state has a low probability of occurring, the Markov chain can have a very long mixing time, requiring many samples to reach the stationary distribution. Instead of starting with a completely random initial cipher, the cipher is initialized by using knowledge about text probabilities. The initialization function picks out all characters that are always followed by the same character, and randomly assigns one of these as the pair "qu" and another as the pair ". ", as these almost always appear in pairs.
